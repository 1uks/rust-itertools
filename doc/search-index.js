var searchIndex = {};
searchIndex['itertools'] = {"items":[[0,"","itertools","Itertools — extra iterator adaptors, functions and macros"],[1,"Interleave","","Alternate elements from two iterators until both\nare run out"],[11,"a","","",0],[11,"b","","",0],[11,"flag","","",0],[1,"Product","","An iterator adaptor that iterates over the cartesian product of\nthe element sets of two iterators `I` and `J`."],[11,"a","","",1],[11,"a_cur","","",1],[11,"b","","",1],[11,"b_orig","","",1],[1,"PutBack","","An iterator adaptor that allows putting back a single\nitem to the front of the iterator."],[11,"top","","",2],[11,"iter","","",2],[1,"FnMap","","Clonable iterator adaptor to map elementwise\nfrom `Iterator<A>` to `Iterator<B>`"],[11,"map","","",3],[11,"iter","","",3],[1,"BoxIter","","A wrapper around `Box<Iterator<A>>` so that it implements the\nIterator trait."],[11,"iter","","The wrapped iterator pointer",4],[1,"Intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator."],[11,"element","","",5],[11,"iter","","",5],[11,"peek","","",5],[11,"insert","","",5],[1,"Stride","","Similar to the slice iterator, but with a certain number of steps\n(stride) skipped per iteration."],[11,"begin","","",6],[11,"end","","",6],[11,"stride","","",6],[11,"life","","",6],[1,"Times","","Iterator to repeat a simple number of times"],[11,"i","","",7],[11,"n","","",7],[3,"times","","Return an iterator with `n` elements, for simple repetition\na particular number of times. The iterator yields a counter."],[6,"AppendTuple","","A helper trait for (x,y,z) ++ w => (x,y,z,w),\nused for implementing `iproduct!` and `izip!`"],[9,"append","","",8],[6,"Itertools","","Extra iterator methods for arbitrary iterators"],[10,"fn_map","","Like regular `.map`, but using a simple function pointer instead,\nso that the resulting `FnMap` iterator value can be cloned.",9],[10,"interleave","","Alternate elements from two iterators until both\nare run out",9],[10,"intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator.",9],[10,"dropn","","Consume `n` elements of the iterator eagerly",9],[10,"drain","","Run the iterator, eagerly, to the end and consume all its elements.",9],[10,"apply","","Run the closure `f` eagerly on each element of the iterator.",9],[10,"write_to","","Assign to each reference in `iter` from this iterator, stopping\nat the shortest of the two iterators.",9],[15,"iproduct!","","Create an iterator over the “cartesian product” of iterators."],[15,"izip!","","Create an iterator running multiple iterators in lockstep."],[15,"icompr!","","`icompr` as in “iterator comprehension” allows creating a\nmapped iterator with simple syntax, similar to set builder notation,\nand directly inspired by Python. Supports an optional filter clause.\n \nSyntax:\n \n `icompr!(<expression> for <pattern> in <iterator>)`"]],"paths":[[1,"Interleave"],[1,"Product"],[1,"PutBack"],[1,"FnMap"],[1,"BoxIter"],[1,"Intersperse"],[1,"Stride"],[1,"Times"],[6,"AppendTuple"],[6,"Itertools"]]};
initSearch(searchIndex);

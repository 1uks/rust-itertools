var searchIndex = {};
searchIndex['itertools'] = {"items":[[0,"","itertools","Itertools — extra iterator adaptors, functions and macros"],[1,"Interleave","","Alternate elements from two iterators until both\nare run out"],[1,"Product","","An iterator adaptor that iterates over the cartesian product of\nthe element sets of two iterators `I` and `J`."],[1,"PutBack","","An iterator adaptor that allows putting back a single\nitem to the front of the iterator."],[1,"FnMap","","Clonable iterator adaptor to map elementwise\nfrom `Iterator<A>` to `Iterator<B>`"],[1,"Dedup","","Remove duplicates from sections of consecutive identical elements.\nIf the iterator is sorted, all elements will be unique."],[1,"Batching","","A “meta iterator adaptor”. Its closure recives a reference to the iterator\nand may pick off as many elements as it likes, to produce the next iterator element."],[1,"GroupBy","","Group iterator elements. Consecutive elements that map to the same key (\"runs\"),\nare returned as the iterator elements of `GroupBy`."],[1,"Step","","An iterator adaptor that steps a number elements in the base iterator\nfor each iteration."],[1,"Intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator."],[1,"ISlice","","A sliced iterator."],[1,"MapMut","","Clonable iterator adaptor to map elementwise\nfrom `Iterator<A>` to `Iterator<B>`"],[1,"RcIter","","A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait."],[11,"rciter","","The boxed iterator.",0],[1,"Stride","","Stride is similar to the slice iterator, but with a certain number of steps\n(the stride) skipped per iteration."],[1,"StrideMut","","StrideMut is like Stride, but with mutable elements."],[1,"Tee","","One half of an iterator pair where both return the same elements."],[1,"Times","","Iterator to repeat a simple number of times"],[1,"ZipLongest","","An iterator which iterates two other iterators simultaneously"],[1,"Zip","","Create an iterator running multiple iterators in lockstep."],[1,"FlatTuples","","A helper iterator that maps an iterator of tuples like\n`((A, B), C)` to an iterator of `(A, B, C)`."],[11,"iter","","",1],[2,"EitherOrBoth","","A value yielded by `ZipLongest`.\nContains one or two values,\ndepending on which of the input iterators are exhausted."],[12,"Both","","Neither input iterator is exhausted yet, yielding two values.",2],[12,"Left","","The parameter iterator of `.zip_longest()` is exhausted,\nonly yielding a value from the `self` iterator.",2],[12,"Right","","The `self` iterator of `.zip_longest()` is exhausted,\nonly yielding a value from the parameter iterator.",2],[3,"times","","Return an iterator with `n` elements, for simple repetition\na particular number of times. The iterator yields a counter."],[3,"linspace","","Return an iterator with `n` elements, where the first\nelement is `a` and the last element is `b`."],[3,"write","","Assign to each reference in `to` from `from`, stopping\nat the shortest of the two iterators."],[10,"clone","","",3],[10,"new","","",3],[10,"next","","",3],[10,"new","","",4],[10,"next","","",4],[10,"size_hint","","",4],[10,"next_back","","",4],[10,"clone","","",4],[10,"clone","","",5],[10,"new","","Iterator element type is `A`",5],[10,"put_back","","Put back a single value to the front of the iterator.",5],[10,"next","","",5],[10,"size_hint","","",5],[10,"clone","","",6],[10,"new","","Create a new cartesian product iterator",6],[10,"next","","",6],[10,"size_hint","","",6],[10,"clone","","",7],[10,"new","","Create a new Dedup Iterator.",7],[10,"next","","",7],[10,"size_hint","","",7],[10,"clone","","",8],[10,"new","","Create a new Batching iterator.",8],[10,"next","","",8],[10,"size_hint","","",8],[10,"clone","","",9],[10,"new","","Create a new GroupBy iterator.",9],[10,"next","","",9],[10,"size_hint","","",9],[10,"clone","","",10],[10,"new","","Create a **Step** iterator.",10],[10,"next","","",10],[10,"size_hint","","",10],[10,"clone","","",11],[10,"new","","Create a new Intersperse iterator",11],[10,"next","","",11],[10,"size_hint","","",11],[10,"clone","","",12],[10,"new","","",12],[10,"next","","",12],[10,"start","core::ops","",13],[10,"end","","",14],[10,"start","","",15],[10,"end","","",15],[10,"new","itertools","",16],[10,"next","","",16],[10,"size_hint","","",16],[10,"next_back","","",16],[10,"clone","","",16],[10,"new","","Create a new RcIter.",0],[10,"clone","","",0],[10,"next","","",0],[10,"size_hint","","",0],[10,"next_back","","",0],[10,"from_ptr_len","","Create a Stride iterator from a raw pointer.",17],[10,"from_ptr_len","","Create a StrideMut iterator from a raw pointer.",18],[10,"from_slice","","Create Stride iterator from a slice and the element step count.",17],[10,"from_stride","","Create Stride iterator from an existing Stride iterator",17],[10,"swap_ends","","Swap the begin and end and reverse the stride,\nin effect reversing the iterator.",17],[10,"len","","Return the number of elements in the iterator.",17],[10,"next","","",17],[10,"size_hint","","",17],[10,"next_back","","",17],[10,"index","","Return a reference to the element at a given index.",17],[10,"fmt","","",17],[10,"from_slice","","Create Stride iterator from a slice and the element step count.",18],[10,"from_stride","","Create Stride iterator from an existing Stride iterator",18],[10,"swap_ends","","Swap the begin and end and reverse the stride,\nin effect reversing the iterator.",18],[10,"len","","Return the number of elements in the iterator.",18],[10,"next","","",18],[10,"size_hint","","",18],[10,"next_back","","",18],[10,"index","","Return a reference to the element at a given index.",18],[10,"fmt","","",18],[10,"clone","","",17],[10,"index_mut","","Return a mutable reference to the element at a given index.",18],[10,"next","","",19],[10,"size_hint","","",19],[10,"clone","","",20],[10,"next","","",20],[10,"size_hint","","",20],[10,"next_back","","",20],[10,"clone","","",21],[10,"new","","Create a new ZipLongest iterator.",21],[10,"next","","",21],[10,"size_hint","","",21],[10,"next_back","","",21],[10,"indexable","","",21],[10,"idx","","",21],[10,"fmt","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"clone","","",22],[10,"new","","Create a new **Zip** from a tuple of iterators.",22],[10,"next","","",22],[10,"size_hint","","",22],[10,"next","","",22],[10,"size_hint","","",22],[10,"next","","",22],[10,"size_hint","","",22],[10,"next","","",22],[10,"size_hint","","",22],[10,"next","","",22],[10,"size_hint","","",22],[10,"next","","",22],[10,"size_hint","","",22],[10,"next","","",22],[10,"size_hint","","",22],[10,"next","","",22],[10,"size_hint","","",22],[10,"next","","",22],[10,"size_hint","","",22],[4,"Linspace","","An iterator of `n` evenly spaced floats.\n \nIterator element type is `F`."],[6,"GenericRange","","**GenericRange** is implemented by Rust's built-in range types, produced\nby range syntax like `a..`, `..b` or `c..d`."],[10,"start","","Start index (inclusive)",23],[10,"end","","End index (exclusive)",23],[6,"Itertools","","Extra iterator methods for arbitrary iterators"],[10,"fn_map","","Like regular `.map`, but using a simple function pointer instead,\nso that the resulting `FnMap` iterator value can be cloned.",24],[10,"map_unboxed","","Like regular `.map`, but using an unboxed closure instead.",24],[10,"interleave","","Alternate elements from two iterators until both\nare run out",24],[10,"intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator.",24],[10,"zip_longest","","Creates an iterator which iterates over both this and the specified\niterators simultaneously, yielding pairs of two optional elements.\nWhen both iterators return None, all further invocations of next() will\nreturn None.",24],[10,"dedup","","Remove duplicates from sections of consecutive identical elements.\nIf the iterator is sorted, all elements will be unique.",24],[10,"batching","","A “meta iterator adaptor”. Its closure recives a reference to the iterator\nand may pick off as many elements as it likes, to produce the next iterator element.",24],[10,"group_by","","Group iterator elements. Consecutive elements that map to the same key (“runs”),\nare returned as the iterator elements of **GroupBy**.",24],[10,"tee","","Split into an iterator pair that both yield all elements from\nthe original iterator.",24],[10,"slice","","Return a sliced iterator.",24],[10,"into_rc","","Return an iterator inside a **Rc\\<RefCell\\<_\\>\\>** wrapper.",24],[10,"step","","Return an iterator adaptor that steps **n** elements in the base iterator\nfor each iteration.",24],[10,"find_position","","Find the position and value of the first element satisfying a predicate.",24],[10,"dropn","","Consume the first **n** elements of the iterator eagerly.",24],[10,"dropping","","Consume the first **n** elements from the iterator eagerly,\nand return the same iterator again.",24],[10,"drain","","Run the iterator, eagerly, to the end and consume all its elements.",24],[10,"apply","","Run the closure **f** eagerly on each element of the iterator.",24],[10,"collect_vec","","**.collec_vec()** is simply a type specialization of **.collect()**,\nfor convenience.",24],[10,"clone","","",1],[4,"Item","",""],[10,"next","","",1],[10,"size_hint","","",1],[10,"next_back","","",1],[15,"iproduct!","","Create an iterator over the “cartesian product” of iterators."],[15,"izip!","","*This macro is deprecated, use* **Zip::new** *instead.*"],[15,"icompr!","","`icompr` as in “iterator comprehension” allows creating a\nmapped iterator with simple syntax, similar to set builder notation,\nand directly inspired by Python. Supports an optional filter clause.\n \nSyntax:\n \n `icompr!(<expression> for <pattern> in <iterator>)`"],[10,"start","","Start index (inclusive)",23],[10,"end","","End index (exclusive)",23]],"paths":[[1,"RcIter"],[1,"FlatTuples"],[2,"EitherOrBoth"],[1,"Interleave"],[1,"FnMap"],[1,"PutBack"],[1,"Product"],[1,"Dedup"],[1,"Batching"],[1,"GroupBy"],[1,"Step"],[1,"Intersperse"],[1,"ISlice"],[1,"RangeFrom"],[1,"RangeTo"],[1,"Range"],[1,"MapMut"],[1,"Stride"],[1,"StrideMut"],[1,"Tee"],[1,"Times"],[1,"ZipLongest"],[1,"Zip"],[6,"GenericRange"],[6,"Itertools"]]};
initSearch(searchIndex);

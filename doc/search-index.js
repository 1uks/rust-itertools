var searchIndex = {};
searchIndex['itertools'] = {"items":[[0,"","itertools","Itertools — extra iterator adaptors, functions and macros"],[1,"Clones","","An iterator like `.map(|elt| elt.clone())`"],[1,"Interleave","","Alternate elements from two iterators until both\nare run out"],[1,"Product","","An iterator adaptor that iterates over the cartesian product of\nthe element sets of two iterators `I` and `J`."],[1,"PutBack","","An iterator adaptor that allows putting back a single\nitem to the front of the iterator."],[1,"FnMap","","Clonable iterator adaptor to map elementwise\nfrom `Iterator<A>` to `Iterator<B>`"],[1,"BoxIter","","A wrapper around `Box<Iterator<A>>` so that it implements the\nIterator trait."],[11,"iter","","The wrapped iterator pointer",0],[1,"Intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator."],[1,"Stride","","Similar to the slice iterator, but with a certain number of steps\n(stride) skipped per iteration."],[1,"StrideMut","","Stride with mutable elements"],[1,"Times","","Iterator to repeat a simple number of times"],[1,"FlatTuples","",""],[11,"iter","","",1],[3,"times","","Return an iterator with `n` elements, for simple repetition\na particular number of times. The iterator yields a counter."],[6,"AppendTuple","","A helper trait for (x,y,z) ++ w => (x,y,z,w),\nused for implementing `iproduct!` and `izip!`"],[9,"append","","",2],[6,"Itertools","","Extra iterator methods for arbitrary iterators"],[10,"fn_map","","Like regular `.map`, but using a simple function pointer instead,\nso that the resulting `FnMap` iterator value can be cloned.",3],[10,"interleave","","Alternate elements from two iterators until both\nare run out",3],[10,"intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator.",3],[10,"dropn","","Consume `n` elements of the iterator eagerly",3],[10,"drain","","Run the iterator, eagerly, to the end and consume all its elements.",3],[10,"apply","","Run the closure `f` eagerly on each element of the iterator.",3],[10,"write_to","","Assign to each reference in `iter` from this iterator, stopping\nat the shortest of the two iterators.",3],[6,"ItertoolsClonable","",""],[10,"clones","","An iterator like `.map(|elt| elt.clone())`",4],[10,"clone","","",1],[10,"next","","",1],[10,"size_hint","","",1],[10,"next_back","","",1],[15,"iproduct!","","Create an iterator over the “cartesian product” of iterators."],[15,"izip!","","Create an iterator running multiple iterators in lockstep."],[15,"icompr!","","`icompr` as in “iterator comprehension” allows creating a\nmapped iterator with simple syntax, similar to set builder notation,\nand directly inspired by Python. Supports an optional filter clause.\n \nSyntax:\n \n `icompr!(<expression> for <pattern> in <iterator>)`"]],"paths":[[1,"BoxIter"],[1,"FlatTuples"],[6,"AppendTuple"],[6,"Itertools"],[6,"ItertoolsClonable"]]};
initSearch(searchIndex);

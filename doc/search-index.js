var searchIndex = {};
searchIndex['itertools'] = {"items":[[0,"","itertools","Itertools — extra iterator adaptors, functions and macros"],[3,"Interleave","","Alternate elements from two iterators until both\nare run out"],[3,"Product","","An iterator adaptor that iterates over the cartesian product of\nthe element sets of two iterators **I** and **J**."],[3,"PutBack","","An iterator adaptor that allows putting back a single\nitem to the front of the iterator."],[3,"FnMap","","Clonable iterator adaptor to map elementwise\nfrom `Iterator<A>` to `Iterator<B>`"],[3,"Dedup","","Remove duplicates from sections of consecutive identical elements.\nIf the iterator is sorted, all elements will be unique."],[3,"Batching","","A “meta iterator adaptor”. Its closure recives a reference to the iterator\nand may pick off as many elements as it likes, to produce the next iterator element."],[3,"GroupBy","","Group iterator elements. Consecutive elements that map to the same key (\"runs\"),\nare returned as the iterator elements of `GroupBy`."],[3,"Step","","An iterator adaptor that steps a number elements in the base iterator\nfor each iteration."],[3,"Merge","","An iterator adaptor that merges the two base iterators in ascending order.\nIf both base iterators are sorted (ascending), the result is sorted."],[3,"EnumerateFrom","",""],[3,"MultiPeek","","An Iterator adaptor that allows the user to peek at multiple *.next()* values without advancing itself."],[3,"Intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator."],[3,"ISlice","","A sliced iterator."],[3,"RcIter","","A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait."],[12,"rciter","","The boxed iterator.",0],[3,"Stride","","Stride is similar to the slice iterator, but with a certain number of steps\n(the stride) skipped per iteration."],[3,"StrideMut","","StrideMut is like Stride, but with mutable elements."],[3,"Tee","","One half of an iterator pair where both return the same elements."],[3,"Times","","Iterator to repeat a simple number of times"],[3,"ZipLongest","","An iterator which iterates two other iterators simultaneously"],[3,"Zip","","Create an iterator running multiple iterators in lockstep."],[3,"ZipTrusted","","Create an iterator running multiple iterators in lockstep."],[4,"EitherOrBoth","","A value yielded by `ZipLongest`.\nContains one or two values,\ndepending on which of the input iterators are exhausted."],[13,"Both","","Neither input iterator is exhausted yet, yielding two values.",1],[13,"Left","","The parameter iterator of `.zip_longest()` is exhausted,\nonly yielding a value from the `self` iterator.",1],[13,"Right","","The `self` iterator of `.zip_longest()` is exhausted,\nonly yielding a value from the parameter iterator.",1],[5,"times","","Return an iterator with `n` elements, for simple repetition\na particular number of times. The iterator yields a counter."],[5,"linspace","","Return an iterator with `n` elements, where the first\nelement is `a` and the last element is `b`."],[5,"write","","**Deprecated: Use *.set_from()* instead**."],[11,"clone","","",2],[11,"new","","",2],[11,"next","","",2],[11,"new","","",3],[11,"next","","",3],[11,"size_hint","","",3],[11,"next_back","","",3],[11,"clone","","",3],[11,"new","","Iterator element type is `A`",4],[11,"put_back","","Put back a single value to the front of the iterator.",4],[11,"next","","",4],[11,"size_hint","","",4],[11,"clone","","",4],[11,"clone","","",5],[11,"new","","Create a new cartesian product iterator",5],[11,"next","","",5],[11,"size_hint","","",5],[11,"clone","","",6],[11,"new","","Create a new Dedup Iterator.",6],[11,"next","","",6],[11,"size_hint","","",6],[11,"clone","","",7],[11,"new","","Create a new Batching iterator.",7],[11,"next","","",7],[11,"size_hint","","",7],[11,"clone","","",8],[11,"new","","Create a new GroupBy iterator.",8],[11,"next","","",8],[11,"size_hint","","",8],[11,"clone","","",9],[11,"new","","Create a **Step** iterator.",9],[11,"next","","",9],[11,"size_hint","","",9],[11,"clone","","",10],[11,"new","","Create a **Merge** iterator.",10],[11,"next","","",10],[11,"size_hint","","",10],[11,"new","","",11],[11,"next","","",11],[11,"new","","Create a **MultiPeek** iterator.",12],[11,"peek","","Works exactly like *.next()* with the only difference that it doesn't advance itself.\n*.peek()* kann be called multiple times, behaving exactly like *.next()*.",12],[11,"next","","",12],[11,"size_hint","","",12],[11,"clone","","",12],[11,"clone","","",13],[11,"new","","Create a new Intersperse iterator",13],[11,"next","","",13],[11,"size_hint","","",13],[11,"clone","","",14],[11,"new","","",14],[11,"next","","",14],[0,"misc","","A module of helper traits and iterators that are not intended to be used\ndirectly."],[3,"FlatTuples","itertools::misc","A helper iterator that maps an iterator of tuples like\n`((A, B), C)` to an iterator of `(A, B, C)`."],[8,"AppendTuple","","A helper trait for (x,y,z) ++ w => (x,y,z,w),\nused for implementing `iproduct!` and `izip!`"],[16,"Result","itertools::misc::AppendTuple",""],[10,"append","itertools::misc","",15],[8,"GenericRange","","**GenericRange** is implemented by Rust's built-in range types, produced\nby range syntax like `a..`, `..b` or `c..d`."],[11,"start","","Start index (inclusive)",16],[11,"end","","End index (exclusive)",16],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[6,"Result","",""],[11,"clone","","",17],[11,"new","","Create a new **FlatTuples**.",17],[6,"Item","",""],[11,"next","","",17],[11,"size_hint","","",17],[11,"next_back","","",17],[11,"start","core::ops","",18],[11,"end","","",19],[11,"start","","",20],[11,"end","","",20],[11,"new","itertools","Create a new RcIter.",0],[11,"clone","","",0],[11,"next","","",0],[11,"size_hint","","",0],[11,"next_back","","",0],[11,"from_ptr_len","","Create a Stride iterator from a raw pointer.",21],[11,"from_ptr_len","","Create a StrideMut iterator from a raw pointer.",22],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",21],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",21],[11,"swap_ends","","Swap the begin and end and reverse the stride,\nin effect reversing the iterator.",21],[11,"len","","Return the number of elements in the iterator.",21],[11,"next","","",21],[11,"size_hint","","",21],[11,"next_back","","",21],[11,"index","","Return a reference to the element at a given index.",21],[11,"fmt","","",21],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",22],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",22],[11,"swap_ends","","Swap the begin and end and reverse the stride,\nin effect reversing the iterator.",22],[11,"len","","Return the number of elements in the iterator.",22],[11,"next","","",22],[11,"size_hint","","",22],[11,"next_back","","",22],[11,"index","","Return a reference to the element at a given index.",22],[11,"fmt","","",22],[11,"clone","","",21],[11,"index_mut","","Return a mutable reference to the element at a given index.",22],[11,"next","","",23],[11,"size_hint","","",23],[11,"clone","","",24],[11,"next","","",24],[11,"size_hint","","",24],[11,"next_back","","",24],[11,"clone","","",25],[11,"new","","Create a new ZipLongest iterator.",25],[11,"next","","",25],[11,"size_hint","","",25],[11,"next_back","","",25],[11,"indexable","","",25],[11,"idx","","",25],[11,"fmt","","",1],[11,"eq","","",1],[11,"ne","","",1],[11,"clone","","",1],[11,"clone","","",26],[11,"new","","Create a new **Zip** from a tuple of iterators.",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"next","","",26],[11,"size_hint","","",26],[11,"clone","","",27],[11,"new","","Create a new **ZipTrusted** from a tuple of iterators.",27],[11,"next","","",27],[11,"size_hint","","",27],[11,"next","","",27],[11,"size_hint","","",27],[11,"next","","",27],[11,"size_hint","","",27],[11,"next","","",27],[11,"size_hint","","",27],[11,"next","","",27],[11,"size_hint","","",27],[11,"next","","",27],[11,"size_hint","","",27],[11,"next","","",27],[11,"size_hint","","",27],[11,"next","","",27],[11,"size_hint","","",27],[11,"next","","",27],[11,"size_hint","","",27],[6,"Linspace","","An iterator of `n` evenly spaced floats."],[8,"TrustedIterator","","A **TrustedIterator** has exact size, always."],[8,"Itertools","","Extra iterator methods for arbitrary iterators"],[11,"fn_map","","Like regular *.map()*, but using a simple function pointer instead,\nso that the resulting **FnMap** iterator value can be cloned.",28],[11,"interleave","","Alternate elements from two iterators until both\nare run out",28],[11,"intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator.",28],[11,"zip_longest","","Creates an iterator which iterates over both this and the specified\niterators simultaneously, yielding pairs of two optional elements.\nWhen both iterators return None, all further invocations of next() will\nreturn None.",28],[11,"dedup","","Remove duplicates from sections of consecutive identical elements.\nIf the iterator is sorted, all elements will be unique.",28],[11,"batching","","A “meta iterator adaptor”. Its closure recives a reference to the iterator\nand may pick off as many elements as it likes, to produce the next iterator element.",28],[11,"group_by","","Group iterator elements. Consecutive elements that map to the same key (“runs”),\nare returned as the iterator elements of **GroupBy**.",28],[11,"tee","","Split into an iterator pair that both yield all elements from\nthe original iterator.",28],[11,"slice","","Return a sliced iterator.",28],[11,"into_rc","","Return an iterator inside a **Rc\\<RefCell\\<_\\>\\>** wrapper.",28],[11,"step","","Return an iterator adaptor that steps **n** elements in the base iterator\nfor each iteration.",28],[11,"merge","","Return an iterator adaptor that merges the two base iterators in ascending order.\nIf both base iterators are sorted (ascending), the result is sorted.",28],[11,"cartesian_product","","Return an iterator adaptor that iterates over the cartesian product of\nthe element sets of two iterators **self** and **J**.",28],[11,"enumerate_from","","Return an iterator adaptor that enumerates the iterator elements,\nstarting from **start** and incrementing by one.",28],[11,"find_position","","Find the position and value of the first element satisfying a predicate.",28],[11,"dropn","","Consume the first **n** elements of the iterator eagerly.",28],[11,"dropping","","Consume the first **n** elements from the iterator eagerly,\nand return the same iterator again.",28],[11,"drain","","**Deprecated:** because of a name clash, use .count() or .foreach() instead as appropriate.",28],[11,"apply","","Run the closure **f** eagerly on each element of the iterator.",28],[11,"foreach","","Run the closure **f** eagerly on each element of the iterator.",28],[11,"collect_vec","","**.collect_vec()** is simply a type specialization of **.collect()**,\nfor convenience.",28],[11,"set_from","","Assign to each reference in **self** from the **from** iterator,\nstopping at the shortest of the two iterators.",28],[11,"join","","Combine all iterator elements into one String, seperated by **sep**.",28],[11,"to_string_join","","Convert all iterators to String before joining them all together.",28],[11,"multipeek","","Returns an iterator adapter that allows peeking multiple values.",28],[14,"iproduct!","","Create an iterator over the “cartesian product” of iterators."],[14,"izip!","","**Note: This macro is deprecated, use *Zip::new* instead.**"],[14,"icompr!","","`icompr` as in “iterator comprehension” allows creating a\nmapped iterator with simple syntax, similar to set builder notation,\nand directly inspired by Python. Supports an optional filter clause."]],"paths":[[3,"RcIter"],[4,"EitherOrBoth"],[3,"Interleave"],[3,"FnMap"],[3,"PutBack"],[3,"Product"],[3,"Dedup"],[3,"Batching"],[3,"GroupBy"],[3,"Step"],[3,"Merge"],[3,"EnumerateFrom"],[3,"MultiPeek"],[3,"Intersperse"],[3,"ISlice"],[8,"AppendTuple"],[8,"GenericRange"],[3,"FlatTuples"],[3,"RangeFrom"],[3,"RangeTo"],[3,"Range"],[3,"Stride"],[3,"StrideMut"],[3,"Tee"],[3,"Times"],[3,"ZipLongest"],[3,"Zip"],[3,"ZipTrusted"],[8,"Itertools"]]};
initSearch(searchIndex);

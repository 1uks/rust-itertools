var searchIndex = {};
searchIndex['itertools'] = {"items":[[0,"","itertools","Itertools — extra iterator adaptors, functions and macros"],[1,"Interleave","","Alternate elements from two iterators until both\nare run out"],[11,"a","","",0],[11,"b","","",0],[11,"flag","","",0],[1,"Product","","An iterator adaptor that iterates over the cartesian product of\nthe element sets of two iterators `I` and `J`."],[11,"a","","",1],[11,"a_cur","","",1],[11,"b","","",1],[11,"b_orig","","",1],[1,"PutBack","","An iterator adaptor that allows putting back a single\nitem to the front of the iterator."],[11,"top","","",2],[11,"iter","","",2],[1,"FnMap","","Clonable iterator adaptor to map elementwise\nfrom `Iterator<A>` to `Iterator<B>`"],[11,"map","","",3],[11,"iter","","",3],[1,"BoxIter","","A wrapper around `Box<Iterator<A>>` so that it implements the\nIterator trait."],[11,"iter","","The wrapped iterator pointer",4],[1,"Stride","","Similar to the slice iterator, but with a certain number of steps\n(stride) skipped per iteration."],[11,"begin","","",5],[11,"end","","",5],[11,"stride","","",5],[11,"life","","",5],[1,"Times","","Iterator to repeat a simple number of times"],[11,"i","","",6],[11,"n","","",6],[3,"times","","Return an iterator with `n` elements, for simple repetition\na particular number of times. The iterator yields a counter."],[3,"append_tuple","",""],[6,"AppendTuple","","A trait for (x,y,z) ++ w => (x,y,z,w)"],[9,"append","","",7],[6,"Itertools","","Extra iterator methods for arbitrary iterators"],[10,"fn_map","","Like regular `.map`, but using a simple function pointer instead,\nso that the resulting `FnMap` iterator value can be cloned.",8],[10,"drain","","Run the iterator to the end and consume all its elements",8],[10,"interleave","","Alternate elements from two iterators until both\nare run out",8],[10,"write_to","","Assign to each reference in `iter` from this iterator, stopping\nat the shortest of the two iterators.",8],[15,"iproduct!","","Create an iterator over the “cartesian product” of iterators."],[15,"icompr!","","`icompr` as in “iterator comprehension” allows creating a\nmapped iterator with simple syntax, similar to set builder notation,\nand directly inspired by Python. Supports an optional filter clause.\n \nSyntax:\n \n `icompr!(<expression> for <pattern> in <iterator>)`"]],"paths":[[1,"Interleave"],[1,"Product"],[1,"PutBack"],[1,"FnMap"],[1,"BoxIter"],[1,"Stride"],[1,"Times"],[6,"AppendTuple"],[6,"Itertools"]]};
initSearch(searchIndex);
